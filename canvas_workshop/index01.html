<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8" />
    <title>Gamedev Phaser Workshop - lesson 01: Initialize the framework</title>
	<style>* { padding: 0; margin: 0; }</style>
	<script src="js/phaser.2.4.2.min.js"></script>
</head>

<body>
<script>//下面参数含义：前两个canvas的宽高(实际值，后面scaleMode设置为SHOW_ALL时，会随html中的父元素自动调整)，第三个渲染方法，第四是canvas父项id（是html中元素，未指定父项设置null，这样就在html最后元素的后面添加），后面是一个状态由phaser载入和开始的三个重要函数组成
    var game = new Phaser.Game(480, 320, Phaser.CANVAS, null, {
      preload: preload, create: create, update: update
    });
	
    function preload() {	
	
	//自动调整画布大小，SHOW_ALL 宽高比不变，图像不会歪斜。屏幕边缘可能会出现黑色条纹，可以忍受。
	//NO_SCALE不调整大小；EXACT_FIT 调整画布在垂直和水平方向上填充所有可用空间，不保留宽高比；
	//还有两个高级选项。
		game.scale.scaleMode = Phaser.ScaleManager.NO_SCALE;	
	//水平和垂直对齐canvas元素，因此无论大小如何，它始终在屏幕上居中。
		game.scale.pageAlignHorizontally = true;
		//game.scale.pageAlignVertically = true;
	//向画布添加自定义背景色	
		game.stage.backgroundColor = '#eee';
		
	//使用Phaser加载图像并打印在画布上比使用纯JavaScript容易得多。
	//使用Phaser创建的game对象执行load.image（）方法，一参数是在game中使用的名称，二参数是相当路径。 
		//game.load.image('ball', 'img/ball.png');
		game.load.image('paddle', 'img/paddle.png')
		game.load.image('brick', 'img/brick.png');
	//后两个参数给定spritesheet文件中每个单个帧的宽度和高度，从而向程序指示如何将其切碎以获取单个帧。
		game.load.spritesheet('ball', 'img/wobble.png', 20, 20);
		//按钮框的宽度为120像素，高度为40像素
		game.load.spritesheet('button', 'img/button.png', 120, 40);
		
		
	}
	
	var ball;//创建球变量。
	var paddle;//创建paddle变量
	var bricks;//将用于创建组，
	var newBrick;//在循环的每次迭代中添加到组中的新对象
	var brickInfo;//存储需要的所有信息。
	var scoreText;
	var score = 0;

	var lives = 3;
	var livesText;
	var lifeLostText;

	var playing = false;
	var startButton;
	
    function create() {
	/*Phaser捆绑了三个不同的物理引擎-Arcade Physics（街机物理），P2和Ninja Physics（忍者物理）-
	以及第四个选项Box2D，可以作为商业插件使用。对于这种简单游戏，可以使用Arcade Physics引擎。
	*/
		game.physics.startSystem(Phaser.Physics.ARCADE);
	//禁用球与屏幕底部边缘的碰撞，如果球拍未击中，球从屏幕掉下
		game.physics.arcade.checkCollision.down = false;
		
		
	//在屏幕上显示球使用Phaser的方法add.sprite（），之后要对其进行操作所以赋给ball变量
		//ball = game.add.sprite(game.world.width*0.5, game.world.height-25, 'ball');
		
		ball = game.add.sprite(game.world.width*0.5, game.world.height-25, 'ball');
		ball.animations.add('wobble', [0,1,0,2,0,1,0,2,0], 24);
		ball.anchor.set(0.5);//锚点定在球的正中间
		game.physics.enable(ball, Phaser.Physics.ARCADE);//为球启用物理系统，默认情况下不启用。
	//为了在屏幕上移动球，其主体设置速度，原来update方法中的移动代码删除
		//ball.body.velocity.set(150, -150);
		//ball.body.gravity.y = 100;	
		ball.body.collideWorldBounds = true;//球将停在屏幕边缘而不消失，但不会反弹。	
		ball.body.bounce.set(1);//设置弹性。		
			
		//检测到这种情况并采取相应方法。
		ball.checkWorldBounds = true;//检测画布边界
		ball.events.onOutOfBounds.add(
			/* function(){//添加监听，发生onOutOfBounds事件时调用方法
				alert('Game over!');
				location.reload();
			} */
			ballLeaveScreen, this);
		
		paddle = game.add.sprite(game.world.width*0.5, game.world.height-5, 'paddle');
		paddle.anchor.set(0.5,1);//更改anchor设置，将锚点放置在paddle宽度中间，高度底部
		game.physics.enable(paddle, Phaser.Physics.ARCADE);//为球拍启用物理系统
		paddle.body.immovable = true;//paddle主体设置为不可移动
	
		initBricks();//
		
		textStyle = { font: '18px Arial', fill: '#0095DD' };
		//三种参数分别为：x和y坐标用于绘制文本；将要呈现的实际文本； 用于呈现文本的字体样式。
		scoreText = game.add.text(5, 5, 'Points: 0', textStyle);
	
		livesText = game.add.text(game.world.width-5, 5, 'Lives: '+lives, textStyle);
		livesText.anchor.set(1,0);	
		
		lifeLostText = game.add.text(game.world.width*0.5, game.world.height*0.5, 'Life lost, click to continue', textStyle);
		lifeLostText.anchor.set(0.5);
		lifeLostText.visible = false;
		
		//参数：按钮坐标，按钮来源，按下按钮时执行的回调函数，指定执行上下文的引用，
		//表示over（鼠标在按钮上1）, out （鼠标离开按钮0）和 down（按下按钮2）事件的帧		
		startButton = game.add.button(game.world.width*0.5, game.world.height*0.5, 'button', startGame, this, 1, 0, 2);
		startButton.anchor.set(0.5);
		
		
	}
    function update() {
	//update函数的代码在每一帧上都被执行，用来改变球的坐标
		//ball.x += 1;
		//ball.y += 1;
		//框架检查每帧上ball和paddle的碰撞检测。
		game.physics.arcade.collide(ball, paddle, ballHitPaddle);
		
		//检测球和砖块组位置。第三个可选参数是发生碰撞时执行的函数。		
		game.physics.arcade.collide(ball, bricks, ballHitBrick);
		
		//根据系统输入（鼠标或触摸，具体取决于平台），设置paddle位置，默认为game.world.width*0.5。
		if(playing){
			paddle.x = game.input.x || game.world.width*0.5;
		}		
		
	}
		
	function initBricks() {
		brickInfo = {	
			width: 50,
			height: 20,//每块砖的宽和高
			count: {//屏幕上看到的砖的行数和列数
				row: 3,
				col: 7
			},
			offset: {//顶部和左侧偏移量（画布上开始砖块的位置）
				top: 50,
				left: 60
			},
			padding: 10//砖块每行和每列间的填充距离
		};
		
		bricks = game.add.group();//添加一个空组表示砖块组
		
		for(c=0; c<brickInfo.count.col; c++) {
			for(r=0; r<brickInfo.count.row; r++) {
				var brickX = (c*(brickInfo.width+brickInfo.padding))+brickInfo.offset.left;
				var brickY = (r*(brickInfo.height+brickInfo.padding))+brickInfo.offset.top;
				newBrick = game.add.sprite(brickX, brickY, 'brick');
				game.physics.enable(newBrick, Phaser.Physics.ARCADE);
				newBrick.body.immovable = true;
				newBrick.anchor.set(0.5);
				bricks.add(newBrick);
				
			}
		}
	}
	
	//函数有两个参数，一是ball，在collide方法中定义该参数，二是与该碰撞的砖块组中的单个砖块。
	function ballHitBrick(ball, brick) {
	
		//brick.kill();//从屏幕上删除转块
		
		var killTween = game.add.tween(brick.scale);
		killTween.to({x:0,y:0}, 200, Phaser.Easing.Linear.None);
		killTween.onComplete.addOnce(function(){
			brick.kill();
		}, this);
		killTween.start(); 
		
		score += 10;
		scoreText.setText('Points: '+score);
		
		if(score === brickInfo.count.row*brickInfo.count.col*10) {
			alert('You won the game, congratulations!');
			location.reload();
		}
		
		//直接使用kill，上面和下面的判断方法效果一致，使用补间后kill上面方法也一致，但下面方法少一次
		//可能是使用补间会延迟吗还是占用？
		/*var count_alive = 0;
		for (i = 0; i < bricks.children.length; i++) {
		  if (bricks.children[i].alive == true) {
			count_alive++;
		  }
		}
		if (count_alive == 0) {
		  alert('You won the game, congratulations!');
		  location.reload();
		}*/
	}
	
	function ballLeaveScreen() {
		lives--;
		if(lives) {
			livesText.setText('Lives: '+lives);
			lifeLostText.visible = true;
			ball.reset(game.world.width*0.5, game.world.height-25);//球和桨的位置屏幕上重置
			paddle.reset(game.world.width*0.5, game.world.height-5);
			game.input.onDown.addOnce(function(){//如果为game.input.onDown.add每次鼠标点击都会调用该函数
			//在下一次输入（单击或触摸）时，该消息将被隐藏，并且球将再次开始移动。
				lifeLostText.visible = false;
				ball.body.velocity.set(150, -150);
			}, this);
		}
		else {
			alert('You lost, game over!');
			location.reload();
		}
		/*add（）和addOnce（）方法之间的区别。add（）方法绑定的函数该函数在每次事件发生时都执行，而addOnce（）在函数执行一次后取消绑定从而不再执行时。 该例子中，每个outOfBounds事件都需要执行ballLeaveScreen，但是当球离开屏幕时，我们只希望从屏幕中删除一次消息。
		*/
	}
	
	function ballHitPaddle(ball, paddle) {
		ball.animations.play('wobble');
		//ball.body.velocity.x = -1*5*(paddle.x-ball.x);
	}
	
	function startGame() {
		startButton.destroy();
		ball.body.velocity.set(150, -150);
		playing = true;
	}
</script>
</body>
</html>